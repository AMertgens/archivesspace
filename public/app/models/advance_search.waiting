require_relative 'search'
require 'advanced_query_builder'

class AdvanceSearch < Search


  attr_accessor :base_search

  # this is still totally banannas..
  def initialize(params = {})
    super
    
    default_types = self[:limit].split(",")
    
    have_query = false
    advanced_query_builder = AdvancedQueryBuilder.new
    self[:q].each_with_index do |query, i|
      query.gsub!(/\[\]/x) { |c| "\\" + c }
      query = "*" if query.blank?
      have_query = true
      op = self[:op][i]
      field = self[:field][i].blank? ? "keyword" : self[:field][i]
      from = self[:from_year][i] || ""
      to = self[:to_year][i] || ""
      
      @base_search += "&" if @base_search.last != "?"
      @base_search += "q[]=#{CGI.escape(query)}&op[]=#{CGI.escape(op)}&field[]=#{CGI.escape(field)}&from_year[]=#{CGI.escape(from)}&to_year[]=#{CGI.escape(to)}"
      
      builder = AdvancedQueryBuilder.new
      # add field part of the row
      builder.and(field, query, "text", op == "NOT")
      # add year range part of the row
      unless from.blank? && to.blank?
        builder.and("years", AdvancedQueryBuilder::RangeValue.new(from, to), "range", op == "NOT")
      end
      # add to the builder based on the op
      if op == "OR"
        advanced_query_builder.or(builder)
      else
        advanced_query_builder.and(builder)
      end
    end
    raise I18n.t("navbar.error_no_term") unless have_query  # just in case we missed something

    # any  search within results?
    self[:filter_q].each do |v|
      value = v == "" ? "*" : v
      advanced_query_builder.and("keyword", value, "text", false)
    end
    # we have to add filtered dates, if they exist
    unless self[:dates_searched] || (self[:filter_to_year].blank? && self[:filter_from_year].blank?)

      from = self[:filter_from_year]
      to = self[:filter_to_year]
      builder = AdvancedQueryBuilder.new
      builder.and("years", AdvancedQueryBuilder::RangeValue.new(from, to), "range", false)
      advanced_query_builder.and(builder)
    end
    
    self[:criteria]["sort"] = @search[:sort] if @search[:sort]  # sort can be passed as default or via params
    
    # if there's an fq passed along...
    unless self[:criteria]["fq"].blank?
      self[:criteria]["fq"].each do |fq |
        f, v = fq.split(":")
        advanced_query_builder.and(f, v, "text", false)
      end
    end

    unless self[:criteria]["repo_id"].blank?
      repo_uri = "/repositories/" + self[:criteria]["repo_id"]

      # Add a filter to limit to this repository (or things that link to it)
      this_repo = AdvancedQueryBuilder.new
      this_repo
        .and("repository", repo_uri, "uri")
        .or("used_within_published_repository", repo_uri, "uri")

      advanced_query_builder.and(this_repo)
    end
    advanced_query_builder.and("types", "pui")
    advanced_query_builder.and("publish", true)
    @base_search += "&limit=#{self[:search][:limit]}" unless self[:limit].blank?

    self[:facet_filter] = FacetFilter.new(self[:filter_fields],self[:filter_values])

    # building the query for the facetting
    type_query_builder = AdvancedQueryBuilder.new
    default_types.reduce(type_query_builder) { |b, type|
      b.or("types", type)
    }

    self[:criteria]["aq"] = advanced_query_builder.build.to_json
    self[:criteria]["filter"] = @facet_filter.get_filter_query.and(type_query_builder).build.to_json
    self[:criteria]["facet[]"] = @facet_filter.get_facet_types
    self[:criteria]["page_size"] = params.fetch(:page_size, AppConfig[:pui_search_results_page_size])



  end

end
